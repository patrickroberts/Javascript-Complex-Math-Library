{"version":3,"file":"complex.min.js","sources":["../internal/mask.ts","../methods/real.ts","../internal/real.ts","../methods/imag.ts","../internal/imag.ts","../internal/abs.ts","../methods/abs.ts","../internal/arg.ts","../methods/arg.ts","../functions/neg.ts","../functions/trunc.ts","../functions/not.ts","../functions/square.ts","../functions/cube.ts","../methods/toString.ts","../methods/add.ts","../methods/sub.ts","../methods/mul.ts","../methods/div.ts","../methods/mod.ts","../methods/pow.ts","../methods/and.ts","../methods/or.ts","../methods/xor.ts","../methods/sal.ts","../methods/sar.ts","../methods/shr.ts","../complex.ts","../functions/from.ts","../functions/polar.ts","../functions/conj.ts","../functions/floor.ts","../functions/ceil.ts","../functions/round.ts","../functions/sign.ts","../functions/random.ts","../functions/exp.ts","../functions/log.ts","../functions/cos.ts","../functions/sin.ts","../functions/tan.ts","../functions/sec.ts","../functions/csc.ts","../functions/cot.ts"],"sourcesContent":["/** @internal */\r\nenum Mask {\r\n  HAS_NONE = 0,\r\n  HAS_REAL = 1,\r\n  HAS_IMAG = HAS_REAL << 1,\r\n  HAS_ABS  = HAS_IMAG << 1,\r\n  HAS_ARG  = HAS_ABS << 1,\r\n  HAS_CARTESIAN = HAS_REAL | HAS_IMAG,\r\n  HAS_POLAR = HAS_ABS | HAS_ARG,\r\n  HAS_ALL = HAS_CARTESIAN | HAS_POLAR\r\n}\r\n\r\nexport default Mask;\r\n","import Complex from '../internal/complex';\r\nimport Mask from '../internal/mask';\r\nimport realImpl from '../internal/real';\r\n\r\nexport default function real (z: Complex): number {\r\n  if (!(z._mask & Mask.HAS_REAL)) {\r\n    z._real = realImpl(z._abs, z._arg);\r\n    z._mask |= Mask.HAS_REAL;\r\n  }\r\n\r\n  return z._real;\r\n}\r\n","export default function real (abs: number, arg: number): number {\r\n  const value =\r\n    // if z is positive, real = abs\r\n    arg === 0 ? abs\r\n    // if z is negative, real = -abs\r\n    : arg === Math.PI ? -abs\r\n    // else real = abs * cos(arg)\r\n    : abs * Math.cos(arg);\r\n\r\n  return value;\r\n}\r\n","import Complex from '../internal/complex';\r\nimport Mask from '../internal/mask';\r\nimport imagImpl from '../internal/imag';\r\n\r\nexport default function imag (z: Complex): number {\r\n  if (!(z._mask & Mask.HAS_IMAG)) {\r\n    z._imag = imagImpl(z._abs, z._arg);\r\n    z._mask |= Mask.HAS_IMAG;\r\n  }\r\n\r\n  return z._imag;\r\n}\r\n","export default function imag (abs: number, arg: number): number {\r\n  const value =\r\n    // if z is real, imag = 0\r\n    arg === 0 || arg === Math.PI ? 0\r\n    // else imag = abs * sin(arg)\r\n    : abs * Math.sin(arg);\r\n\r\n  return value;\r\n}\r\n","export default function abs (real: number, imag: number): number {\r\n  const value =\r\n    // if z is real, abs = |real|\r\n    imag === 0 ? Math.abs(real)\r\n    // if z is imag, abs = |imag|\r\n    : real === 0 ? Math.abs(imag)\r\n    // else abs = |z|\r\n    : Math.hypot(real, imag);\r\n\r\n  return value;\r\n}\r\n","import Complex from '../internal/complex';\r\nimport Mask from '../internal/mask';\r\nimport absImpl from '../internal/abs';\r\n\r\nexport default function abs (z: Complex): number {\r\n  if (!(z._mask & Mask.HAS_ABS)) {\r\n    z._abs = absImpl(z._real, z._imag);\r\n    z._mask |= Mask.HAS_ABS;\r\n  }\r\n\r\n  return z._abs;\r\n}\r\n","export default function arg (real: number, imag: number): number {\r\n  const value =\r\n    // if z is real, if z is negative, arg = pi, else arg = 0\r\n    imag === 0 ? (real < 0 ? Math.PI : 0)\r\n    // if z is imag, arg = sign(imag) * pi / 2\r\n    : real === 0 ? (imag < 0 ? -0.5 : 0.5) * Math.PI\r\n    // else arg = atan(imag / real)\r\n    : Math.atan2(imag, real);\r\n\r\n  return value;\r\n}\r\n","import Complex from '../internal/complex';\r\nimport Mask from '../internal/mask';\r\nimport argImpl from '../internal/arg';\r\n\r\nexport default function arg (z: Complex): number {\r\n  if (!(z._mask & Mask.HAS_ARG)) {\r\n    z._arg = argImpl(z._real, z._imag);\r\n    z._mask |= Mask.HAS_ARG;\r\n  }\r\n\r\n  return z._arg;\r\n}\r\n","import Complex, { ComplexConstructor } from '../internal/complex';\r\nimport Mask from '../internal/mask';\r\n\r\nexport default function neg<T extends Complex> (Complex: ComplexConstructor<T>, z: Complex | number, imag: number = 0): T {\r\n  let zReal: number, zImag: number, zAbs: number, zArg: number, zMask: Mask;\r\n\r\n  if (typeof z === 'number') {\r\n    zReal = z; zImag = imag; zAbs = NaN; zArg = NaN; zMask = Mask.HAS_CARTESIAN;\r\n  } else {\r\n    zReal = z._real; zImag = z._imag; zAbs = z._abs; zArg = z._arg; zMask = z._mask;\r\n  }\r\n\r\n  return new Complex(-zReal, -zImag, zAbs, zArg + Math.PI, zMask);\r\n}\r\n","import Complex, { ComplexConstructor } from '../internal/complex';\r\nimport Mask from '../internal/mask';\r\nimport getReal from '../methods/real';\r\nimport getImag from '../methods/imag';\r\n\r\nexport default function trunc<T extends Complex> (Complex: ComplexConstructor<T>, z: Complex | number, imag: number = 0): T {\r\n  let zReal: number, zImag: number;\r\n\r\n  if (typeof z === 'number') {\r\n    zReal = z; zImag = imag;\r\n  } else {\r\n    zReal = getReal(z); zImag = getImag(z);\r\n  }\r\n\r\n  return new Complex(Math.trunc(zReal), Math.trunc(zImag), NaN, NaN, Mask.HAS_CARTESIAN);\r\n}\r\n","import Complex, { ComplexConstructor } from '../internal/complex';\r\nimport Mask from '../internal/mask';\r\nimport getReal from '../methods/real';\r\nimport getImag from '../methods/imag';\r\n\r\nexport default function not<T extends Complex> (Complex: ComplexConstructor<T>, z: Complex | number, imag: number = 0): T {\r\n  let zReal: number, zImag: number;\r\n\r\n  if (typeof z === 'number') {\r\n    zReal = z; zImag = imag;\r\n  } else {\r\n    zReal = getReal(z); zImag = getImag(z);\r\n  }\r\n\r\n  return new Complex(~zReal, ~zImag, NaN, NaN, Mask.HAS_CARTESIAN);\r\n}\r\n","import Complex, { ComplexConstructor } from '../internal/complex';\r\nimport Mask from '../internal/mask';\r\n\r\nexport default function square<T extends Complex> (Complex: ComplexConstructor<T>, z: Complex | number, imag: number = 0): T {\r\n  let zReal: number, zImag: number, zAbs: number, zArg: number, zMask: Mask;\r\n\r\n  if (typeof z === 'number') {\r\n    zReal = z; zImag = imag; zAbs = NaN; zArg = NaN; zMask = Mask.HAS_CARTESIAN;\r\n  } else {\r\n    zReal = z._real; zImag = z._imag; zAbs = z._abs; zArg = z._arg; zMask = z._mask;\r\n  }\r\n\r\n  const real2 = zReal * zReal;\r\n  const imag2 = zImag * zImag;\r\n  const abs2 = zMask & Mask.HAS_ABS\r\n    ? zAbs * zAbs\r\n    : real2 + imag2;\r\n\r\n  return new Complex(real2, imag2, abs2, zArg * 2, zMask | Mask.HAS_ABS);\r\n}\r\n","import Complex, { ComplexConstructor } from '../internal/complex';\r\nimport Mask from '../internal/mask';\r\n\r\nexport default function cube<T extends Complex> (Complex: ComplexConstructor<T>, z: Complex | number, imag: number = 0): T {\r\n  let zReal: number, zImag: number, zAbs: number, zArg: number, zMask: Mask;\r\n\r\n  if (typeof z === 'number') {\r\n    zReal = z; zImag = imag; zAbs = NaN; zArg = NaN; zMask = Mask.HAS_CARTESIAN;\r\n  } else {\r\n    zReal = z._real; zImag = z._imag; zAbs = z._abs; zArg = z._arg; zMask = z._mask;\r\n  }\r\n\r\n  const abs3 = zAbs * zAbs * zAbs;\r\n  const arg3 = zArg * 3;\r\n\r\n  if ((zMask & Mask.HAS_CARTESIAN) !== Mask.HAS_CARTESIAN) {\r\n    return new Complex(NaN, NaN, abs3, arg3, Mask.HAS_POLAR);\r\n  }\r\n\r\n  const real2 = zReal * zReal;\r\n  const imag2 = zImag * zImag;\r\n  const real3 = (real2 - imag2 * 3) * zReal;\r\n  const imag3 = (real2 * 3 - imag2) * zImag;\r\n\r\n  return new Complex(real3, imag3, arg3, abs3, zMask);\r\n}\r\n","import Complex from '../internal/complex';\r\nimport getReal from './real';\r\nimport getImag from './imag';\r\nimport getAbs from './abs';\r\nimport getArg from './arg';\r\n\r\n/** @internal */\r\ntype Coordinates = 'c' | 'p';\r\n/** @internal */\r\ntype Radix = 'X' | 'x' | 'o' | 'b' | '';\r\n/** @internal */\r\ntype Specifier = 'r' | 'i' | 'm' | 'a';\r\n/** @internal */\r\ninterface Format {\r\n  pound: boolean;\r\n  zero: boolean;\r\n  plus: boolean;\r\n  minus: boolean;\r\n  width: number;\r\n  precision: number;\r\n  radix: Radix;\r\n  specifier: Specifier;\r\n}\r\n\r\nconst fmtCoord = /%([cp])/g;\r\nconst fmtParts = /%([#0+-]{,4})(\\d{,2})((?:\\.\\d{,2})?)([Xxob]?)([rima])/g;\r\n\r\nexport default function toString (z: Complex, format = '%c'): string {\r\n  return format\r\n    .replace(fmtCoord, replaceCoord)\r\n    .replace(fmtParts, replaceParts(z));\r\n}\r\n\r\nfunction replaceCoord (_: string, coord: Coordinates): string {\r\n  switch (coord) {\r\n    case 'c': return '%r%+ii';\r\n    case 'p': return '%m*e**(%ai)';\r\n  }\r\n}\r\n\r\nfunction replaceParts (z: Complex): (...args: string[]) => string {\r\n  return (_, flag, width, precision, radix, specifier) => {\r\n    return stringify(z, {\r\n      pound: flag.includes('#'),\r\n      zero: flag.includes('0'),\r\n      plus: flag.includes('+'),\r\n      minus: flag.includes('-'),\r\n      width: +width,\r\n      precision: +precision.slice(1),\r\n      radix: radix as Radix,\r\n      specifier: specifier as Specifier\r\n    });\r\n  };\r\n}\r\n\r\nfunction stringify (z: Complex, format: Format): string {\r\n  return width(precision(radix(specifier())));\r\n\r\n  function specifier (): number {\r\n    switch (format.specifier) {\r\n      case 'r': return getReal(z);\r\n      case 'i': return getImag(z);\r\n      case 'm': return getAbs(z);\r\n      case 'a': return getArg(z);\r\n    }\r\n  }\r\n\r\n  function radix (num: number): string {\r\n    switch (format.radix) {\r\n      case 'X': return num.toString(16).toUpperCase();\r\n      case 'x': return num.toString(16).toLowerCase();\r\n      case 'o': return num.toString(8);\r\n      case 'b': return num.toString(2);\r\n      case '': return num.toString(10);\r\n    }\r\n  }\r\n\r\n  function precision (str: string): string {\r\n    const target = format.precision;\r\n    const index = str.indexOf('.') + 1;\r\n\r\n    if (index === 0) {\r\n      if (target === 0) return str;\r\n\r\n      return str + '.' + '0'.repeat(target);\r\n    }\r\n\r\n    const digits = str.length - index;\r\n    const remove = Math.max(digits - target, 0);\r\n    const insert = Math.max(target - digits, 0);\r\n\r\n    return str.slice(0, str.length - remove) + '0'.repeat(insert);\r\n  }\r\n\r\n  function width (str: string): string {\r\n    if (format.minus) {\r\n      return padRight(plus(pound(str)), format.width, ' ');\r\n    }\r\n\r\n    if (!format.zero) {\r\n      return padLeft(plus(pound(str)), format.width, ' ');\r\n    }\r\n\r\n    if (!str.startsWith('-')) {\r\n      return plus(pound(padLeft(str, format.width, '0')));\r\n    }\r\n\r\n    return plus(pound('-' + padLeft(str.slice(1), format.width - 1, '0')));\r\n  }\r\n\r\n  function plus (str: string) {\r\n    if (!format.plus || str.startsWith('-')) return str;\r\n    return '+' + str;\r\n  }\r\n\r\n  function pound (str: string): string {\r\n    if (!format.pound || !format.radix) return str;\r\n\r\n    const base = '0' + format.radix;\r\n\r\n    if (!str.startsWith('-')) return base + str;\r\n    return '-' + base + str.slice(1);\r\n  }\r\n}\r\n\r\nfunction padLeft (target: string, targetLength: number, padString: string): string {\r\n  targetLength >>= 0;\r\n  targetLength -= target.length;\r\n\r\n  if (targetLength <= 0) return target;\r\n\r\n  return padded(targetLength, padString) + target;\r\n}\r\n\r\nfunction padRight (target: string, targetLength: number, padString: string): string {\r\n  targetLength >>= 0;\r\n  targetLength -= target.length;\r\n\r\n  if (targetLength <= 0) return target;\r\n\r\n  return target + padded(targetLength, padString);\r\n}\r\n\r\nfunction padded (targetLength: number, padString: string): string {\r\n  if (targetLength > padString.length) {\r\n    padString += padString.repeat(targetLength / padString.length);\r\n  }\r\n\r\n  return padString.slice(0, targetLength);\r\n}\r\n","import Complex, { ComplexConstructor } from '../internal/complex';\r\nimport Mask from '../internal/mask';\r\nimport getReal from './real';\r\nimport getImag from './imag';\r\n\r\nexport default function add<T extends Complex> (Complex: ComplexConstructor<T>, lhs: Complex, rhs: Complex | number, imag: number = 0): T {\r\n  let rhsReal: number; let rhsImag: number;\r\n\r\n  if (typeof rhs === 'number') {\r\n    rhsReal = rhs; rhsImag = imag;\r\n  } else {\r\n    rhsReal = getReal(rhs); rhsImag = getImag(rhs);\r\n  }\r\n\r\n  const lhsReal = getReal(lhs);\r\n  const lhsImag = getImag(lhs);\r\n\r\n  return new Complex(lhsReal + rhsReal, lhsImag + rhsImag, NaN, NaN, Mask.HAS_CARTESIAN);\r\n}\r\n","import Complex, { ComplexConstructor } from '../internal/complex';\r\nimport Mask from '../internal/mask';\r\nimport getReal from './real';\r\nimport getImag from './imag';\r\n\r\nexport default function sub<T extends Complex> (Complex: ComplexConstructor<T>, lhs: Complex, rhs: Complex | number, imag: number = 0): T {\r\n  let rhsReal: number; let rhsImag: number;\r\n  \r\n  if (typeof rhs === 'number') {\r\n    rhsReal = rhs; rhsImag = imag;\r\n  } else {\r\n    rhsReal = getReal(rhs); rhsImag = getImag(rhs);\r\n  }\r\n\r\n  const lhsReal = getReal(lhs);\r\n  const lhsImag = getImag(lhs);\r\n  \r\n  return new Complex(\r\n    lhsReal - rhsReal,\r\n    lhsImag - rhsImag,\r\n    NaN,\r\n    NaN,\r\n    Mask.HAS_CARTESIAN\r\n  );\r\n}\r\n","import Complex, { ComplexConstructor } from '../internal/complex';\r\nimport Mask from '../internal/mask';\r\nimport getReal from './real';\r\nimport getImag from './imag';\r\nimport getAbs from './abs';\r\nimport getArg from './arg';\r\n\r\nexport default function mul<T extends Complex> (Complex: ComplexConstructor<T>, lhs: Complex, rhs: Complex | number, imag: number = 0): T {\r\n  if (typeof rhs === 'number') {\r\n    rhs = new Complex(rhs, imag, NaN, NaN, Mask.HAS_CARTESIAN);\r\n  }\r\n\r\n  const mask = lhs._mask & rhs._mask;\r\n\r\n  switch (mask) {\r\n    case Mask.HAS_ALL:\r\n    case Mask.HAS_CARTESIAN | Mask.HAS_ABS:\r\n    case Mask.HAS_CARTESIAN | Mask.HAS_ARG:\r\n    case Mask.HAS_CARTESIAN:\r\n      return new Complex(\r\n        lhs._real * rhs._real - lhs._imag * rhs._imag,\r\n        lhs._imag * rhs._real + lhs._real * rhs._imag,\r\n        lhs._abs * rhs._abs,\r\n        lhs._arg + rhs._arg,\r\n        mask\r\n      );\r\n    case Mask.HAS_REAL:\r\n    case Mask.HAS_IMAG:\r\n      return new Complex(\r\n        getReal(lhs) * getReal(rhs) - getImag(lhs) * getImag(rhs),\r\n        lhs._imag * rhs._real + lhs._real * rhs._imag,\r\n        NaN,\r\n        NaN,\r\n        Mask.HAS_CARTESIAN\r\n      );\r\n    default:\r\n      return new Complex(\r\n        NaN,\r\n        NaN,\r\n        getAbs(lhs) * getAbs(rhs),\r\n        getArg(lhs) + getArg(rhs),\r\n        Mask.HAS_POLAR\r\n      );\r\n  }\r\n}\r\n","import Complex, { ComplexConstructor } from '../internal/complex';\r\nimport Mask from '../internal/mask';\r\nimport getReal from './real';\r\nimport getImag from './imag';\r\nimport getAbs from './abs';\r\nimport getArg from './arg';\r\n\r\nexport default function div<T extends Complex> (Complex: ComplexConstructor<T>, lhs: Complex, rhs: Complex | number, imag: number = 0): T {\r\n  if (typeof rhs === 'number') {\r\n    rhs = new Complex(rhs, imag, NaN, NaN, Mask.HAS_CARTESIAN);\r\n  }\r\n\r\n  const mask = lhs._mask & rhs._mask;\r\n  let rhsAbs2: number;\r\n\r\n  switch (mask) {\r\n    case Mask.HAS_ALL:\r\n    case Mask.HAS_CARTESIAN | Mask.HAS_ABS:\r\n      rhsAbs2 = rhs._abs * rhs._abs;\r\n      return new Complex(\r\n        (lhs._real * rhs._real + lhs._imag * rhs._imag) / rhsAbs2,\r\n        (lhs._imag * rhs._real - lhs._real * rhs._imag) / rhsAbs2,\r\n        lhs._abs / rhs._abs,\r\n        lhs._arg - rhs._arg,\r\n        mask\r\n      );\r\n    case Mask.HAS_CARTESIAN | Mask.HAS_ARG:\r\n      rhsAbs2 = rhs._real * rhs._real + rhs._imag * rhs._imag;\r\n      return new Complex(\r\n        (lhs._real * rhs._real + lhs._imag * rhs._imag) / rhsAbs2,\r\n        (lhs._imag * rhs._real - lhs._real * rhs._imag) / rhsAbs2,\r\n        NaN,\r\n        lhs._arg - rhs._arg,\r\n        mask\r\n      );\r\n    case Mask.HAS_CARTESIAN:\r\n    case Mask.HAS_REAL:\r\n    case Mask.HAS_IMAG:\r\n      rhsAbs2 = getReal(rhs) * rhs._real + getImag(rhs) * rhs._imag;\r\n      return new Complex(\r\n        (getReal(lhs) * rhs._real + getImag(lhs) * rhs._imag) / rhsAbs2,\r\n        (lhs._imag * rhs._real - lhs._real * rhs._imag) / rhsAbs2,\r\n        NaN,\r\n        NaN,\r\n        Mask.HAS_CARTESIAN\r\n      );\r\n    default:\r\n      return new Complex(\r\n        NaN,\r\n        NaN,\r\n        getAbs(lhs) / getAbs(rhs),\r\n        getArg(lhs) - getArg(rhs),\r\n        Mask.HAS_POLAR\r\n      );\r\n  }\r\n}\r\n","import Complex, { ComplexConstructor } from '../internal/complex';\r\nimport truncImpl from '../functions/trunc';\r\nimport divImpl from './div';\r\nimport mulImpl from './mul';\r\nimport subImpl from './sub';\r\n\r\nexport default function mod<T extends Complex> (Complex: ComplexConstructor<T>, dividend: Complex, divisor: Complex | number, imag: number = 0): T {\r\n  // dividend % divisor = dividend - (trunc(dividend / divisor) * divisor)\r\n  const q = divImpl(Complex, dividend, divisor, imag);\r\n  const p = mulImpl(Complex, truncImpl(Complex, q), divisor, imag);\r\n\r\n  return subImpl(Complex, dividend, p);\r\n}\r\n","import Complex, { ComplexConstructor } from '../internal/complex';\r\nimport Mask from '../internal/mask';\r\nimport getReal from './real';\r\nimport getImag from './imag';\r\nimport getAbs from './abs';\r\nimport getArg from './arg';\r\nimport divImpl from './div';\r\nimport squareImpl from '../functions/square';\r\nimport cubeImpl from '../functions/cube';\r\n\r\nexport default function pow<T extends Complex> (Complex: ComplexConstructor<T>, w: Complex, z: Complex | number, imag: number = 0): T {\r\n  // z = c + di\r\n  let c: number; let d: number;\r\n  \r\n  if (typeof z === 'number') {\r\n    c = z; d = imag;\r\n  } else {\r\n    c = getReal(z); d = getImag(z);\r\n  }\r\n\r\n  if (d === 0) {\r\n    const o = Complex['1'];\r\n\r\n    switch (c) {\r\n      case -1: return divImpl(Complex, o, w);\r\n      case 0: return new Complex(o._real, o._imag, o._abs, o._arg, o._mask);\r\n      case 1: return new Complex(w._real, w._imag, w._abs, w._arg, w._mask);\r\n      case 2: return squareImpl(Complex, w);\r\n      case 3: return cubeImpl(Complex, w);\r\n    }\r\n  }\r\n\r\n  // w = r e ** ia\r\n  const r = getAbs(w);\r\n  const a = getArg(w);\r\n\r\n  // w ** z === (r ** c * e ** -ad) e ** i(d ln(r) + ac)\r\n  // from https://en.wikipedia.org/wiki/Exponentiation#Computing_complex_powers\r\n  const abs = Math.pow(r, c) * Math.exp(-a * d);\r\n  const arg = d * Math.log(r) + a * c;\r\n\r\n  return new Complex(NaN, NaN, abs, arg, Mask.HAS_POLAR);\r\n}\r\n","import Complex, { ComplexConstructor } from '../internal/complex';\r\nimport Mask from '../internal/mask';\r\nimport getReal from './real';\r\nimport getImag from './imag';\r\n\r\nexport default function and<T extends Complex> (Complex: ComplexConstructor<T>, lhs: Complex, rhs: Complex | number, imag: number = 0): T {\r\n  let rhsReal: number; let rhsImag: number;\r\n\r\n  if (typeof rhs === 'number') {\r\n    rhsReal = rhs; rhsImag = imag;\r\n  } else {\r\n    rhsReal = getReal(rhs); rhsImag = getImag(rhs);\r\n  }\r\n\r\n  const lhsReal = getReal(lhs);\r\n  const lhsImag = getImag(lhs);\r\n  \r\n  return new Complex(lhsReal & rhsReal, lhsImag & rhsImag, NaN, NaN, Mask.HAS_CARTESIAN);\r\n}\r\n","import Complex, { ComplexConstructor } from '../internal/complex';\r\nimport Mask from '../internal/mask';\r\nimport getReal from './real';\r\nimport getImag from './imag';\r\n\r\nexport default function or<T extends Complex> (Complex: ComplexConstructor<T>, lhs: Complex, rhs: Complex | number, imag: number = 0): T {\r\n  let rhsReal: number; let rhsImag: number;\r\n  \r\n  if (typeof rhs === 'number') {\r\n    rhsReal = rhs; rhsImag = imag;\r\n  } else {\r\n    rhsReal = getReal(rhs); rhsImag = getImag(rhs);\r\n  }\r\n\r\n  const lhsReal = getReal(lhs);\r\n  const lhsImag = getImag(lhs);\r\n  \r\n  return new Complex(\r\n    lhsReal | rhsReal,\r\n    lhsImag | rhsImag,\r\n    NaN,\r\n    NaN,\r\n    Mask.HAS_CARTESIAN\r\n  );\r\n}\r\n","import Complex, { ComplexConstructor } from '../internal/complex';\r\nimport Mask from '../internal/mask';\r\nimport getReal from './real';\r\nimport getImag from './imag';\r\n\r\nexport default function xor<T extends Complex> (Complex: ComplexConstructor<T>, lhs: Complex, rhs: Complex | number, imag: number = 0): T {\r\n  let rhsReal: number; let rhsImag: number;\r\n  \r\n  if (typeof rhs === 'number') {\r\n    rhsReal = rhs; rhsImag = imag;\r\n  } else {\r\n    rhsReal = getReal(rhs); rhsImag = getImag(rhs);\r\n  }\r\n\r\n  const lhsReal = getReal(lhs);\r\n  const lhsImag = getImag(lhs);\r\n  \r\n  return new Complex(\r\n    lhsReal ^ rhsReal,\r\n    lhsImag ^ rhsImag,\r\n    NaN,\r\n    NaN,\r\n    Mask.HAS_CARTESIAN\r\n  );\r\n}\r\n","import Complex, { ComplexConstructor } from '../internal/complex';\r\nimport Mask from '../internal/mask';\r\nimport getReal from './real';\r\nimport getImag from './imag';\r\n\r\nexport default function sal<T extends Complex> (Complex: ComplexConstructor<T>, lhs: Complex, rhs: Complex | number, imag: number = 0): T {\r\n  let rhsReal: number; let rhsImag: number;\r\n  \r\n  if (typeof rhs === 'number') {\r\n    rhsReal = rhs; rhsImag = imag;\r\n  } else {\r\n    rhsReal = getReal(rhs); rhsImag = getImag(rhs);\r\n  }\r\n\r\n  const lhsReal = getReal(lhs);\r\n  const lhsImag = getImag(lhs);\r\n  \r\n  return new Complex(\r\n    lhsReal << rhsReal,\r\n    lhsImag << rhsImag,\r\n    NaN,\r\n    NaN,\r\n    Mask.HAS_CARTESIAN\r\n  );\r\n}\r\n","import Complex, { ComplexConstructor } from '../internal/complex';\r\nimport Mask from '../internal/mask';\r\nimport getReal from './real';\r\nimport getImag from './imag';\r\n\r\nexport default function sar<T extends Complex> (Complex: ComplexConstructor<T>, lhs: Complex, rhs: Complex | number, imag: number = 0): T {\r\n  let rhsReal: number; let rhsImag: number;\r\n  \r\n  if (typeof rhs === 'number') {\r\n    rhsReal = rhs; rhsImag = imag;\r\n  } else {\r\n    rhsReal = getReal(rhs); rhsImag = getImag(rhs);\r\n  }\r\n\r\n  const lhsReal = getReal(lhs);\r\n  const lhsImag = getImag(lhs);\r\n  \r\n  return new Complex(\r\n    lhsReal >> rhsReal,\r\n    lhsImag >> rhsImag,\r\n    NaN,\r\n    NaN,\r\n    Mask.HAS_CARTESIAN\r\n  );\r\n}\r\n","import Complex, { ComplexConstructor } from '../internal/complex';\r\nimport Mask from '../internal/mask';\r\nimport getReal from './real';\r\nimport getImag from './imag';\r\n\r\nexport default function shr<T extends Complex> (Complex: ComplexConstructor<T>, lhs: Complex, rhs: Complex | number, imag: number = 0): T {\r\n  let rhsReal: number; let rhsImag: number;\r\n  \r\n  if (typeof rhs === 'number') {\r\n    rhsReal = rhs; rhsImag = imag;\r\n  } else {\r\n    rhsReal = getReal(rhs); rhsImag = getImag(rhs);\r\n  }\r\n\r\n  const lhsReal = getReal(lhs);\r\n  const lhsImag = getImag(lhs);\r\n  \r\n  return new Complex(\r\n    lhsReal >>> rhsReal,\r\n    lhsImag >>> rhsImag,\r\n    NaN,\r\n    NaN,\r\n    Mask.HAS_CARTESIAN\r\n  );\r\n}\r\n","import Mask from './internal/mask';\r\nimport realImpl from './methods/real';\r\nimport imagImpl from './methods/imag';\r\nimport absImpl from './methods/abs';\r\nimport argImpl from './methods/arg';\r\nimport fromImpl from './functions/from';\r\nimport polarImpl from './functions/polar';\r\nimport negImpl from './functions/neg';\r\nimport conjImpl from './functions/conj';\r\nimport signImpl from './functions/sign';\r\nimport ceilImpl from './functions/ceil';\r\nimport floorImpl from './functions/floor';\r\nimport roundImpl from './functions/round';\r\nimport truncImpl from './functions/trunc';\r\nimport notImpl from './functions/not';\r\nimport randomImpl from './functions/random';\r\nimport squareImpl from './functions/square';\r\nimport cubeImpl from './functions/cube';\r\nimport expImpl from './functions/exp';\r\nimport logImpl from './functions/log';\r\nimport cosImpl from './functions/cos';\r\nimport sinImpl from './functions/sin';\r\nimport tanImpl from './functions/tan';\r\nimport secImpl from './functions/sec';\r\nimport cscImpl from './functions/csc';\r\nimport cotImpl from './functions/cot';\r\nimport toStringImpl from './methods/toString';\r\nimport addImpl from './methods/add';\r\nimport subImpl from './methods/sub';\r\nimport mulImpl from './methods/mul';\r\nimport divImpl from './methods/div';\r\nimport modImpl from './methods/mod';\r\nimport powImpl from './methods/pow';\r\nimport andImpl from './methods/and';\r\nimport orImpl from './methods/or';\r\nimport xorImpl from './methods/xor';\r\nimport salImpl from './methods/sal';\r\nimport sarImpl from './methods/sar';\r\nimport shrImpl from './methods/shr';\r\n\r\nexport default class Complex {\r\n  /** @internal */\r\n  public constructor (real: number, imag: number, abs: number, arg: number, mask: Mask) {\r\n    // coerce -0 to +0\r\n    if (mask & Mask.HAS_REAL) real += 0;\r\n    if (mask & Mask.HAS_IMAG) imag += 0;\r\n    if (mask & Mask.HAS_ABS) abs += 0;\r\n    // choose branch cut as the interval (-pi, pi]\r\n    if (mask & Mask.HAS_ARG) arg = Math.PI - ((Math.PI - arg) % (Math.PI * 2));\r\n\r\n    this._real = real;\r\n    this._imag = imag;\r\n    this._abs = abs;\r\n    this._arg = arg;\r\n    this._mask = mask;\r\n  }\r\n\r\n  /** @internal */\r\n  public _real: number;\r\n  /** @internal */\r\n  public _imag: number;\r\n  /** @internal */\r\n  public _abs: number;\r\n  /** @internal */\r\n  public _arg: number;\r\n  /** @internal */\r\n  public _mask: Mask;\r\n\r\n  public get real (): number {\r\n    return realImpl(this);\r\n  }\r\n\r\n  public get imag (): number {\r\n    return imagImpl(this);\r\n  }\r\n\r\n  public get abs (): number {\r\n    return absImpl(this);\r\n  }\r\n\r\n  public get arg (): number {\r\n    return argImpl(this);\r\n  }\r\n\r\n  public static readonly '0' = Complex.from(0);\r\n  public static readonly '1' = Complex.from(1);\r\n  public static readonly 'I' = Complex.from(0, 1);\r\n  public static readonly 'E' = Complex.from(Math.E);\r\n  public static readonly 'PI' = Complex.from(Math.PI);\r\n\r\n  public static from (real: number, imag?: number): Complex;\r\n  public static from (z: Complex | number): Complex;\r\n  public static from (z: Complex | number, imag?: number): Complex {\r\n    return fromImpl(Complex, z, imag);\r\n  }\r\n\r\n  public static cartesian (real: number, imag: number = 0): Complex {\r\n    return new Complex(real, imag, NaN, NaN, Mask.HAS_CARTESIAN);\r\n  }\r\n\r\n  public static polar (abs: number, arg?: number): Complex {\r\n    return polarImpl(Complex, abs, arg);\r\n  }\r\n\r\n  public static neg (z: Complex | number): Complex;\r\n  public static neg (real: number, imag?: number): Complex;\r\n  public static neg (z: Complex | number, imag?: number): Complex {\r\n    return negImpl(Complex, z, imag);\r\n  }\r\n  public static '-' (z: Complex | number): Complex;\r\n  public static '-' (real: number, imag?: number): Complex;\r\n  public static '-' (z: Complex | number, imag?: number): Complex {\r\n    return negImpl(Complex, z, imag);\r\n  }\r\n\r\n  public static conj (z: Complex | number): Complex;\r\n  public static conj (real: number, imag?: number): Complex;\r\n  public static conj (z: Complex | number, imag?: number): Complex {\r\n    return conjImpl(Complex, z, imag);\r\n  }\r\n\r\n  public static floor (z: Complex | number): Complex;\r\n  public static floor (real: number, imag?: number): Complex;\r\n  public static floor (z: Complex | number, imag?: number): Complex {\r\n    return floorImpl(Complex, z, imag);\r\n  }\r\n\r\n  public static ceil (z: Complex | number): Complex;\r\n  public static ceil (real: number, imag?: number): Complex;\r\n  public static ceil (z: Complex | number, imag?: number): Complex {\r\n    return ceilImpl(Complex, z, imag);\r\n  }\r\n\r\n  public static round (z: Complex | number): Complex;\r\n  public static round (real: number, imag?: number): Complex;\r\n  public static round (z: Complex | number, imag?: number): Complex {\r\n    return roundImpl(Complex, z, imag);\r\n  }\r\n\r\n  public static sign (z: Complex | number): Complex;\r\n  public static sign (real: number, imag?: number): Complex;\r\n  public static sign (z: Complex | number, imag?: number): Complex {\r\n    return signImpl(Complex, z, imag);\r\n  }\r\n\r\n  public static trunc (z: Complex | number): Complex;\r\n  public static trunc (real: number, imag?: number): Complex;\r\n  public static trunc (z: Complex | number, imag?: number): Complex {\r\n    return truncImpl(Complex, z, imag);\r\n  }\r\n\r\n  public static not (z: Complex | number): Complex;\r\n  public static not (real: number, imag?: number): Complex;\r\n  public static not (z: Complex | number, imag?: number): Complex {\r\n    return notImpl(Complex, z, imag);\r\n  }\r\n  public static '~' (z: Complex | number): Complex;\r\n  public static '~' (real: number, imag?: number): Complex;\r\n  public static '~' (z: Complex | number, imag?: number): Complex {\r\n    return notImpl(Complex, z, imag);\r\n  }\r\n\r\n  public static random (): Complex {\r\n    return randomImpl(Complex);\r\n  }\r\n\r\n  public static square (z: Complex | number): Complex;\r\n  public static square (real: number, imag?: number): Complex;\r\n  public static square (z: Complex | number, imag?: number): Complex {\r\n    return squareImpl(Complex, z, imag);\r\n  }\r\n\r\n  public static cube (z: Complex | number): Complex;\r\n  public static cube (real: number, imag?: number): Complex;\r\n  public static cube (z: Complex | number, imag?: number): Complex {\r\n    return cubeImpl(Complex, z, imag);\r\n  }\r\n\r\n  public static exp (z: Complex | number): Complex;\r\n  public static exp (real: number, imag?: number): Complex;\r\n  public static exp (z: Complex | number, imag?: number): Complex {\r\n    return expImpl(Complex, z, imag);\r\n  }\r\n\r\n  public static log (z: Complex | number): Complex;\r\n  public static log (real: number, imag?: number): Complex;\r\n  public static log (z: Complex | number, imag?: number): Complex {\r\n    return logImpl(Complex, z, imag);\r\n  }\r\n\r\n  public static cos (z: Complex | number): Complex;\r\n  public static cos (real: number, imag?: number): Complex;\r\n  public static cos (z: Complex | number, imag?: number): Complex {\r\n    return cosImpl(Complex, z, imag);\r\n  }\r\n\r\n  public static sin (z: Complex | number): Complex;\r\n  public static sin (real: number, imag?: number): Complex;\r\n  public static sin (z: Complex | number, imag?: number): Complex {\r\n    return sinImpl(Complex, z, imag);\r\n  }\r\n\r\n  public static tan (z: Complex | number): Complex;\r\n  public static tan (real: number, imag?: number): Complex;\r\n  public static tan (z: Complex | number, imag?: number): Complex {\r\n    return tanImpl(Complex, z, imag);\r\n  }\r\n\r\n  public static sec (z: Complex | number): Complex;\r\n  public static sec (real: number, imag?: number): Complex;\r\n  public static sec (z: Complex | number, imag?: number): Complex {\r\n    return secImpl(Complex, z, imag);\r\n  }\r\n\r\n  public static csc (z: Complex | number): Complex;\r\n  public static csc (real: number, imag?: number): Complex;\r\n  public static csc (z: Complex | number, imag?: number): Complex {\r\n    return cscImpl(Complex, z, imag);\r\n  }\r\n\r\n  public static cot (z: Complex | number): Complex;\r\n  public static cot (real: number, imag?: number): Complex;\r\n  public static cot (z: Complex | number, imag?: number): Complex {\r\n    return cotImpl(Complex, z, imag);\r\n  }\r\n\r\n  public toString (format?: string): string {\r\n    return toStringImpl(this, format);\r\n  }\r\n\r\n  public add (rhs: Complex | number): Complex;\r\n  public add (real: number, imag?: number): Complex;\r\n  public add (rhs: Complex | number, imag?: number): Complex {\r\n    return addImpl(Complex, this, rhs, imag);\r\n  }\r\n  public '+' (rhs: Complex | number): Complex;\r\n  public '+' (real: number, imag?: number): Complex;\r\n  public '+' (rhs: Complex | number, imag?: number): Complex {\r\n    return addImpl(Complex, this, rhs, imag);\r\n  }\r\n\r\n  public sub (rhs: Complex | number): Complex;\r\n  public sub (real: number, imag?: number): Complex;\r\n  public sub (rhs: Complex | number, imag?: number): Complex {\r\n    return subImpl(Complex, this, rhs, imag);\r\n  }\r\n  public '-' (rhs: Complex | number): Complex;\r\n  public '-' (real: number, imag?: number): Complex;\r\n  public '-' (rhs: Complex | number, imag?: number): Complex {\r\n    return subImpl(Complex, this, rhs, imag);\r\n  }\r\n\r\n  public mul (rhs: Complex | number): Complex;\r\n  public mul (real: number, imag?: number): Complex;\r\n  public mul (rhs: Complex | number, imag?: number): Complex {\r\n    return mulImpl(Complex, this, rhs, imag);\r\n  }\r\n  public '*' (rhs: Complex | number): Complex;\r\n  public '*' (real: number, imag?: number): Complex;\r\n  public '*' (rhs: Complex | number, imag?: number): Complex {\r\n    return mulImpl(Complex, this, rhs, imag);\r\n  }\r\n\r\n  public div (divisor: Complex | number): Complex;\r\n  public div (real: number, imag?: number): Complex;\r\n  public div (divisor: Complex | number, imag?: number): Complex {\r\n    return divImpl(Complex, this, divisor, imag);\r\n  }\r\n  public '/' (rhs: Complex | number): Complex;\r\n  public '/' (real: number, imag?: number): Complex;\r\n  public '/' (rhs: Complex | number, imag?: number): Complex {\r\n    return divImpl(Complex, this, rhs, imag);\r\n  }\r\n\r\n  public mod (rhs: Complex | number): Complex;\r\n  public mod (real: number, imag?: number): Complex;\r\n  public mod (rhs: Complex | number, imag?: number): Complex {\r\n    return modImpl(Complex, this, rhs, imag);\r\n  }\r\n  public '%' (rhs: Complex | number): Complex;\r\n  public '%' (real: number, imag?: number): Complex;\r\n  public '%' (rhs: Complex | number, imag?: number): Complex {\r\n    return modImpl(Complex, this, rhs, imag);\r\n  }\r\n\r\n  public pow (rhs: Complex | number): Complex;\r\n  public pow (real: number, imag?: number): Complex;\r\n  public pow (rhs: Complex | number, imag?: number): Complex {\r\n    return powImpl(Complex, this, rhs, imag);\r\n  }\r\n  public '**' (rhs: Complex | number): Complex;\r\n  public '**' (real: number, imag?: number): Complex;\r\n  public '**' (rhs: Complex | number, imag?: number): Complex {\r\n    return powImpl(Complex, this, rhs, imag);\r\n  }\r\n\r\n  public and (rhs: Complex | number): Complex;\r\n  public and (real: number, imag?: number): Complex;\r\n  public and (rhs: Complex | number, imag?: number): Complex {\r\n    return andImpl(Complex, this, rhs, imag);\r\n  }\r\n  public '&' (rhs: Complex | number): Complex;\r\n  public '&' (real: number, imag?: number): Complex;\r\n  public '&' (rhs: Complex | number, imag?: number): Complex {\r\n    return andImpl(Complex, this, rhs, imag);\r\n  }\r\n\r\n  public or (rhs: Complex | number): Complex;\r\n  public or (real: number, imag?: number): Complex;\r\n  public or (rhs: Complex | number, imag?: number): Complex {\r\n    return orImpl(Complex, this, rhs, imag);\r\n  }\r\n  public '|' (rhs: Complex | number): Complex;\r\n  public '|' (real: number, imag?: number): Complex;\r\n  public '|' (rhs: Complex | number, imag?: number): Complex {\r\n    return orImpl(Complex, this, rhs, imag);\r\n  }\r\n\r\n  public xor (rhs: Complex | number): Complex;\r\n  public xor (real: number, imag?: number): Complex;\r\n  public xor (rhs: Complex | number, imag?: number): Complex {\r\n    return xorImpl(Complex, this, rhs, imag);\r\n  }\r\n  public '^' (rhs: Complex | number): Complex;\r\n  public '^' (real: number, imag?: number): Complex;\r\n  public '^' (rhs: Complex | number, imag?: number): Complex {\r\n    return xorImpl(Complex, this, rhs, imag);\r\n  }\r\n\r\n  public sal (rhs: Complex | number): Complex;\r\n  public sal (real: number, imag?: number): Complex;\r\n  public sal (rhs: Complex | number, imag?: number): Complex {\r\n    return salImpl(Complex, this, rhs, imag);\r\n  }\r\n  public shl (rhs: Complex | number): Complex;\r\n  public shl (real: number, imag?: number): Complex;\r\n  public shl (rhs: Complex | number, imag?: number): Complex {\r\n    return salImpl(Complex, this, rhs, imag);\r\n  }\r\n  public '<<' (rhs: Complex | number): Complex;\r\n  public '<<' (real: number, imag?: number): Complex;\r\n  public '<<' (rhs: Complex | number, imag?: number): Complex {\r\n    return salImpl(Complex, this, rhs, imag);\r\n  }\r\n\r\n  public sar (rhs: Complex | number): Complex;\r\n  public sar (real: number, imag?: number): Complex;\r\n  public sar (rhs: Complex | number, imag?: number): Complex {\r\n    return sarImpl(Complex, this, rhs, imag);\r\n  }\r\n  public '>>' (rhs: Complex | number): Complex;\r\n  public '>>' (real: number, imag?: number): Complex;\r\n  public '>>' (rhs: Complex | number, imag?: number): Complex {\r\n    return sarImpl(Complex, this, rhs, imag);\r\n  }\r\n\r\n  public shr (rhs: Complex | number): Complex;\r\n  public shr (real: number, imag?: number): Complex;\r\n  public shr (rhs: Complex | number, imag?: number): Complex {\r\n    return shrImpl(Complex, this, rhs, imag);\r\n  }\r\n  public '>>>' (rhs: Complex | number): Complex;\r\n  public '>>>' (real: number, imag?: number): Complex;\r\n  public '>>>' (rhs: Complex | number, imag?: number): Complex {\r\n    return shrImpl(Complex, this, rhs, imag);\r\n  }\r\n}\r\n","import Complex, { ComplexConstructor } from '../internal/complex';\r\nimport Mask from '../internal/mask';\r\nimport absImpl from '../internal/abs';\r\nimport argImpl from '../internal/arg';\r\nimport getReal from '../methods/real';\r\nimport getImag from '../methods/imag';\r\nimport getAbs from '../methods/abs';\r\nimport getArg from '../methods/arg';\r\n\r\nexport default function from<T extends Complex> (Complex: ComplexConstructor<T>, z: Complex | number, imag: number = 0): T {\r\n  let zReal: number, zImag: number, zAbs: number, zArg: number;\r\n\r\n  if (typeof z === 'number') {\r\n    zReal = z; zImag = imag; zAbs = absImpl(z, imag); zArg = argImpl(z, imag);\r\n  } else {\r\n    zReal = getReal(z); zImag = getImag(z); zAbs = getAbs(z); zArg = getArg(z);\r\n  }\r\n\r\n  return new Complex(zReal, zImag, zAbs, zArg, Mask.HAS_ALL);\r\n}\r\n","import Complex, { ComplexConstructor } from '../internal/complex';\r\nimport Mask from '../internal/mask';\r\n\r\nexport default function polar<T extends Complex> (Complex: ComplexConstructor<T>, abs: number, arg: number = 0): T {\r\n  let zAbs: number, zArg: number;\r\n\r\n  if (abs < 0) {\r\n    zAbs = -abs; zArg = arg + Math.PI;\r\n  } else {\r\n    zAbs = abs; zArg = arg;\r\n  }\r\n\r\n  return new Complex(NaN, NaN, zAbs, zArg, Mask.HAS_POLAR);\r\n}\r\n","import Complex, { ComplexConstructor } from '../internal/complex';\r\nimport Mask from '../internal/mask';\r\n\r\nexport default function conj<T extends Complex> (Complex: ComplexConstructor<T>, z: Complex | number, imag: number = 0): T {\r\n  let zReal: number, zImag: number, zAbs: number, zArg: number, zMask: Mask;\r\n\r\n  if (typeof z === 'number') {\r\n    zReal = z; zImag = imag; zAbs = NaN; zArg = NaN; zMask = Mask.HAS_CARTESIAN;\r\n  } else {\r\n    zReal = z._real; zImag = z._imag; zAbs = z._abs; zArg = z._arg; zMask = z._mask;\r\n  }\r\n\r\n  return new Complex(zReal, -zImag, zAbs, -zArg, zMask);\r\n}\r\n","import Complex, { ComplexConstructor } from '../internal/complex';\r\nimport Mask from '../internal/mask';\r\nimport getReal from '../methods/real';\r\nimport getImag from '../methods/imag';\r\n\r\nexport default function floor<T extends Complex> (Complex: ComplexConstructor<T>, z: Complex | number, imag: number = 0): T {\r\n  let zReal: number, zImag: number;\r\n\r\n  if (typeof z === 'number') {\r\n    zReal = z; zImag = imag;\r\n  } else {\r\n    zReal = getReal(z); zImag = getImag(z);\r\n  }\r\n\r\n  return new Complex(Math.floor(zReal), Math.floor(zImag), NaN, NaN, Mask.HAS_CARTESIAN);\r\n}\r\n","import Complex, { ComplexConstructor } from '../internal/complex';\r\nimport Mask from '../internal/mask';\r\nimport getReal from '../methods/real';\r\nimport getImag from '../methods/imag';\r\n\r\nexport default function ceil<T extends Complex> (Complex: ComplexConstructor<T>, z: Complex | number, imag: number = 0): T {\r\n  let zReal: number, zImag: number;\r\n\r\n  if (typeof z === 'number') {\r\n    zReal = z; zImag = imag;\r\n  } else {\r\n    zReal = getReal(z); zImag = getImag(z);\r\n  }\r\n\r\n  return new Complex(Math.ceil(zReal), Math.ceil(zImag), NaN, NaN, Mask.HAS_CARTESIAN);\r\n}\r\n","import Complex, { ComplexConstructor } from '../internal/complex';\r\nimport Mask from '../internal/mask';\r\nimport getReal from '../methods/real';\r\nimport getImag from '../methods/imag';\r\n\r\nexport default function round<T extends Complex> (Complex: ComplexConstructor<T>, z: Complex | number, imag: number = 0): T {\r\n  let zReal: number, zImag: number;\r\n\r\n  if (typeof z === 'number') {\r\n    zReal = z; zImag = imag;\r\n  } else {\r\n    zReal = getReal(z); zImag = getImag(z);\r\n  }\r\n\r\n  return new Complex(Math.round(zReal), Math.round(zImag), NaN, NaN, Mask.HAS_CARTESIAN);\r\n}\r\n","import Complex, { ComplexConstructor } from '../internal/complex';\r\nimport Mask from '../internal/mask';\r\nimport absImpl from '../internal/abs';\r\nimport argImpl from '../internal/arg';\r\nimport getAbs from '../methods/abs';\r\nimport getArg from '../methods/arg';\r\n\r\nexport default function sign<T extends Complex> (Complex: ComplexConstructor<T>, z: Complex | number, imag: number = 0): T {\r\n  let zReal: number, zImag: number, zAbs: number, zArg: number, zMask: Mask;\r\n\r\n  if (typeof z === 'number') {\r\n    zReal = z; zImag = imag; zAbs = absImpl(z, imag); zArg = NaN; zMask = Mask.HAS_CARTESIAN;\r\n  } else {\r\n    zReal = z._real; zImag = z._imag; zAbs = getAbs(z); zArg = z._arg; zMask = z._mask;\r\n  }\r\n\r\n  if (zAbs === 0) {\r\n    return new Complex(0, 0, 0, 0, Mask.HAS_ALL);\r\n  }\r\n\r\n  if (zAbs !== Infinity) {\r\n    return new Complex(zReal / zAbs, zImag / zAbs, 1, zArg, zMask | Mask.HAS_ABS);\r\n  }\r\n\r\n  const arg = typeof z === 'number'\r\n    ? argImpl(zReal, zImag)\r\n    : getArg(z);\r\n\r\n  return new Complex(NaN, NaN, 1, arg, Mask.HAS_POLAR);\r\n}\r\n","import Complex, { ComplexConstructor } from '../internal/complex';\r\nimport Mask from '../internal/mask';\r\n\r\nexport default function random<T extends Complex> (Complex: ComplexConstructor<T>): T {\r\n  return new Complex(Math.random(), Math.random(), NaN, NaN, Mask.HAS_CARTESIAN);\r\n}\r\n","import Complex, { ComplexConstructor } from '../internal/complex';\r\nimport Mask from '../internal/mask';\r\nimport getReal from '../methods/real';\r\nimport getImag from '../methods/imag';\r\n\r\nexport default function exp<T extends Complex> (Complex: ComplexConstructor<T>, z: Complex | number, imag: number = 0): T {\r\n  let zReal: number, zImag: number;\r\n\r\n  if (typeof z === 'number') {\r\n    zReal = z; zImag = imag;\r\n  } else {\r\n    zReal = getReal(z); zImag = getImag(z);\r\n  }\r\n\r\n  return new Complex(\r\n    NaN,\r\n    NaN,\r\n    Math.exp(zReal),\r\n    zImag,\r\n    Mask.HAS_POLAR \r\n  );\r\n}\r\n","import Complex, { ComplexConstructor } from '../internal/complex';\r\nimport Mask from '../internal/mask';\r\nimport absImpl from '../internal/abs';\r\nimport argImpl from '../internal/arg';\r\nimport getAbs from '../methods/abs';\r\nimport getArg from '../methods/arg';\r\n\r\nexport default function log<T extends Complex> (Complex: ComplexConstructor<T>, z: Complex | number, imag: number = 0): T {\r\n  let zAbs: number, zArg: number;\r\n\r\n  if (typeof z === 'number') {\r\n    zAbs = absImpl(z, imag); zArg = argImpl(z, imag);\r\n  } else {\r\n    zAbs = getAbs(z); zArg = getArg(z);\r\n  }\r\n\r\n  return new Complex(\r\n    Math.log(zAbs),\r\n    zArg,\r\n    NaN,\r\n    NaN,\r\n    Mask.HAS_CARTESIAN \r\n  );\r\n}\r\n","import Complex, { ComplexConstructor } from '../internal/complex';\r\nimport Mask from '../internal/mask';\r\nimport getReal from '../methods/real';\r\nimport getImag from '../methods/imag';\r\n\r\nexport default function cos<T extends Complex> (Complex: ComplexConstructor<T>, z: Complex | number, imag: number = 0): T {\r\n  let zReal: number, zImag: number;\r\n\r\n  if (typeof z === 'number') {\r\n    zReal = z; zImag = imag;\r\n  } else {\r\n    zReal = getReal(z); zImag = getImag(z);\r\n  }\r\n\r\n  if (zImag === 0) {\r\n    const zCos = Math.cos(zReal);\r\n\r\n    return new Complex(\r\n      zCos,\r\n      0,\r\n      Math.abs(zCos),\r\n      zCos < 0 ? Math.PI : 0,\r\n      Mask.HAS_ALL\r\n    );\r\n  }\r\n\r\n  if (zReal === 0) {\r\n    const zCos = Math.cosh(zImag);\r\n\r\n    return new Complex(\r\n      zCos,\r\n      0,\r\n      Math.abs(zCos),\r\n      zCos < 0 ? Math.PI : 0,\r\n      Mask.HAS_ALL\r\n    );\r\n  }\r\n\r\n  return new Complex(\r\n    Math.cos(zReal) * Math.cosh(zImag),\r\n    Math.sin(zReal) * Math.sinh(zImag),\r\n    NaN,\r\n    NaN,\r\n    Mask.HAS_CARTESIAN \r\n  );\r\n}\r\n","import Complex, { ComplexConstructor } from '../internal/complex';\r\nimport Mask from '../internal/mask';\r\nimport getReal from '../methods/real';\r\nimport getImag from '../methods/imag';\r\n\r\nexport default function sin<T extends Complex> (Complex: ComplexConstructor<T>, z: Complex | number, imag: number = 0): T {\r\n  let zReal: number, zImag: number;\r\n\r\n  if (typeof z === 'number') {\r\n    zReal = z; zImag = imag;\r\n  } else {\r\n    zReal = getReal(z); zImag = getImag(z);\r\n  }\r\n\r\n  if (zImag === 0) {\r\n    const zSin = Math.sin(zReal);\r\n\r\n    return new Complex(\r\n      zSin,\r\n      0,\r\n      Math.abs(zSin),\r\n      zSin < 0 ? Math.PI : 0,\r\n      Mask.HAS_ALL\r\n    );\r\n  }\r\n\r\n  if (zReal === 0) {\r\n    const zSin = Math.sinh(zImag);\r\n\r\n    return new Complex(\r\n      0,\r\n      zSin,\r\n      Math.abs(zSin),\r\n      (zSin < 0 ? -0.5 : 0.5) * Math.PI,\r\n      Mask.HAS_ALL\r\n    );\r\n  }\r\n\r\n  return new Complex(\r\n    Math.sin(zReal) * Math.cosh(zImag),\r\n    Math.cos(zReal) * Math.sinh(zImag),\r\n    NaN,\r\n    NaN,\r\n    Mask.HAS_CARTESIAN \r\n  );\r\n}\r\n","import Complex, { ComplexConstructor } from '../internal/complex';\r\nimport Mask from '../internal/mask';\r\nimport getReal from '../methods/real';\r\nimport getImag from '../methods/imag';\r\n\r\nexport default function tan<T extends Complex> (Complex: ComplexConstructor<T>, z: Complex | number, imag: number = 0): T {\r\n  let zReal: number, zImag: number;\r\n\r\n  if (typeof z === 'number') {\r\n    zReal = z; zImag = imag;\r\n  } else {\r\n    zReal = getReal(z); zImag = getImag(z);\r\n  }\r\n\r\n  if (zImag === 0) {\r\n    const zTan = Math.sin(2 * zReal) / (Math.cos(2 * zReal) + 1);\r\n\r\n    return new Complex(\r\n      zTan,\r\n      0,\r\n      Math.abs(zTan),\r\n      zTan < 0 ? Math.PI : 0,\r\n      Mask.HAS_ALL\r\n    );\r\n  }\r\n\r\n  if (zReal === 0) {\r\n    const zTan = Math.sinh(2 * zImag) / (1 + Math.cosh(2 * zImag));\r\n\r\n    return new Complex(\r\n      0,\r\n      zTan,\r\n      Math.abs(zTan),\r\n      (zTan < 0 ? -0.5 : 0.5) * Math.PI,\r\n      Mask.HAS_ALL\r\n    );\r\n  }\r\n\r\n  const zTanDenom = Math.cos(2 * zReal) + Math.cosh(2 * zImag);\r\n\r\n  return new Complex(\r\n    Math.sin(2 * zReal) / zTanDenom,\r\n    Math.sinh(2 * zImag) / zTanDenom,\r\n    NaN,\r\n    NaN,\r\n    Mask.HAS_CARTESIAN \r\n  );\r\n}\r\n","import Complex, { ComplexConstructor } from '../internal/complex';\r\nimport Mask from '../internal/mask';\r\nimport getReal from '../methods/real';\r\nimport getImag from '../methods/imag';\r\n\r\nexport default function sec<T extends Complex> (Complex: ComplexConstructor<T>, z: Complex | number, imag: number = 0): T {\r\n  let zReal: number, zImag: number;\r\n\r\n  if (typeof z === 'number') {\r\n    zReal = z; zImag = imag;\r\n  } else {\r\n    zReal = getReal(z); zImag = getImag(z);\r\n  }\r\n\r\n  if (zImag === 0) {\r\n    const zSec = 2 * Math.cos(zReal) / (Math.cos(2 * zReal) + 1);\r\n\r\n    return new Complex(\r\n      zSec,\r\n      0,\r\n      Math.abs(zSec),\r\n      zSec < 0 ? Math.PI : 0,\r\n      Mask.HAS_ALL\r\n    );\r\n  }\r\n\r\n  if (zReal === 0) {\r\n    const zSec = 2 * Math.cosh(zImag) / (1 + Math.cosh(2 * zImag));\r\n\r\n    return new Complex(\r\n      zSec,\r\n      0,\r\n      Math.abs(zSec),\r\n      zSec < 0 ? Math.PI : 0,\r\n      Mask.HAS_ALL\r\n    );\r\n  }\r\n\r\n  const zSecDenom = Math.cos(2 * zReal) + Math.cosh(2 * zImag);\r\n\r\n  return new Complex(\r\n    2 * Math.cos(zReal) * Math.cosh(zImag) / zSecDenom,\r\n    2 * Math.sin(zReal) * Math.sinh(zImag) / zSecDenom,\r\n    NaN,\r\n    NaN,\r\n    Mask.HAS_CARTESIAN \r\n  );\r\n}\r\n","import Complex, { ComplexConstructor } from '../internal/complex';\r\nimport Mask from '../internal/mask';\r\nimport getReal from '../methods/real';\r\nimport getImag from '../methods/imag';\r\n\r\nexport default function sec<T extends Complex> (Complex: ComplexConstructor<T>, z: Complex | number, imag: number = 0): T {\r\n  let zReal: number, zImag: number;\r\n\r\n  if (typeof z === 'number') {\r\n    zReal = z; zImag = imag;\r\n  } else {\r\n    zReal = getReal(z); zImag = getImag(z);\r\n  }\r\n\r\n  if (zImag === 0) {\r\n    const zCsc = -2 * Math.sin(zReal) / (Math.cos(2 * zReal) - 1);\r\n\r\n    return new Complex(\r\n      zCsc,\r\n      0,\r\n      Math.abs(zCsc),\r\n      zCsc < 0 ? Math.PI : 0,\r\n      Mask.HAS_ALL\r\n    );\r\n  }\r\n\r\n  if (zReal === 0) {\r\n    const zCsc = 2 * Math.sinh(zImag) / (1 - Math.cosh(2 * zImag));\r\n\r\n    return new Complex(\r\n      0,\r\n      zCsc,\r\n      Math.abs(zCsc),\r\n      (zCsc < 0 ? -0.5 : 0.5) * Math.PI,\r\n      Mask.HAS_ALL\r\n    );\r\n  }\r\n\r\n  const zCscDenom = Math.cos(2 * zReal) - Math.cosh(2 * zImag);\r\n\r\n  return new Complex(\r\n    -2 * Math.sin(zReal) * Math.cosh(zImag) / zCscDenom,\r\n    2 * Math.cos(zReal) * Math.sinh(zImag) / zCscDenom,\r\n    NaN,\r\n    NaN,\r\n    Mask.HAS_CARTESIAN \r\n  );\r\n}\r\n","import Complex, { ComplexConstructor } from '../internal/complex';\r\nimport Mask from '../internal/mask';\r\nimport getReal from '../methods/real';\r\nimport getImag from '../methods/imag';\r\n\r\nexport default function cot<T extends Complex> (Complex: ComplexConstructor<T>, z: Complex | number, imag: number = 0): T {\r\n  let zReal: number, zImag: number;\r\n\r\n  if (typeof z === 'number') {\r\n    zReal = z; zImag = imag;\r\n  } else {\r\n    zReal = getReal(z); zImag = getImag(z);\r\n  }\r\n\r\n  if (zImag === 0) {\r\n    const zCot = -Math.sin(2 * zReal) / (Math.cos(2 * zReal) - 1);\r\n\r\n    return new Complex(\r\n      zCot,\r\n      0,\r\n      Math.abs(zCot),\r\n      zCot < 0 ? Math.PI : 0,\r\n      Mask.HAS_ALL\r\n    );\r\n  }\r\n\r\n  if (zReal === 0) {\r\n    const zCot = Math.sinh(2 * zImag) / (1 - Math.cosh(2 * zImag));\r\n\r\n    return new Complex(\r\n      0,\r\n      zCot,\r\n      Math.abs(zCot),\r\n      (zCot < 0 ? -0.5 : 0.5) * Math.PI,\r\n      Mask.HAS_ALL\r\n    );\r\n  }\r\n\r\n  const zCotDenom = Math.cos(2 * zReal) - Math.cosh(2 * zImag);\r\n\r\n  return new Complex(\r\n    -Math.sin(2 * zReal) / zCotDenom,\r\n    Math.sinh(2 * zImag) / zCotDenom,\r\n    NaN,\r\n    NaN,\r\n    Mask.HAS_CARTESIAN \r\n  );\r\n}\r\n"],"names":["Mask","real","z","_mask","HAS_REAL","_real","abs","arg","Math","PI","cos","realImpl","_abs","_arg","imag","HAS_IMAG","_imag","sin","imagImpl","hypot","HAS_ABS","absImpl","atan2","HAS_ARG","argImpl","neg","Complex","zReal","zImag","zAbs","zArg","zMask","NaN","HAS_CARTESIAN","trunc","getReal","getImag","not","square","real2","imag2","cube","abs3","arg3","HAS_POLAR","fmtCoord","fmtParts","toString","format","replace","replaceCoord","_","flag","width","precision","radix","specifier","str","minus","target","plus","pound","targetLength","padString","length","padded","zero","padLeft","startsWith","slice","index","indexOf","repeat","digits","remove","max","insert","num","toUpperCase","toLowerCase","getAbs","getArg","base","stringify","includes","replaceParts","coord","add","lhs","rhs","rhsReal","rhsImag","sub","mul","mask","HAS_ALL","div","rhsAbs2","mod","dividend","divisor","subImpl","mulImpl","truncImpl","divImpl","pow","w","c","d","o","squareImpl","cubeImpl","r","a","exp","log","and","or","xor","sal","sar","shr","this","Object","fromImpl","polarImpl","negImpl","conjImpl","floor","floorImpl","ceil","ceilImpl","round","roundImpl","Infinity","signImpl","notImpl","random","randomImpl","expImpl","logImpl","zCos","cosh","sinh","cosImpl","zSin","sinImpl","zTan","zTanDenom","tanImpl","zSec","zSecDenom","secImpl","zCsc","zCscDenom","cscImpl","zCot","zCotDenom","cotImpl","toStringImpl","addImpl","modImpl","powImpl","andImpl","orImpl","xorImpl","salImpl","sarImpl","shrImpl","from","E"],"mappings":"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"}